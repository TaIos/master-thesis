\newpage


\section{Layout construction}\label{sec:layout-construction}

This section describes the process of how to transform or decode an individual.
This transformation aims to create a solution to the painting placement problem,
which is a set of placement points for the paintings.
There are multiple steps to this process.

\begin{enumerate}
    \item Individual decoding (\ref{subsec:individual-decoding}).
    \item Slicing tree construction (\ref{subsec:slicing-tree-construction}).
    \item Slicing layout construction (\ref{subsec:slicing-tree-construction}).
    \item Using placement heuristic to create a painting placement solution (\ref{subsec:placement-heuristics}).
\end{enumerate}

Steps in the transformation of an individual to the painting placement solution are
in figure~\ref{fig:layout-construction-steps}.
All of them steps are explained in the following text.

\begin{figure}[h!]
    \includegraphics[height=0.65\textheight, center]{layout_construction_steps}
    \caption{Steps in the transformation of an individual to the painting placement solution.}
    \label{fig:layout-construction-steps}
\end{figure}

\subsection{Individual decoding}\label{subsec:individual-decoding}
First, we must decode an individual to the representation from which a slicing layout can be constructed.
A decoded individual is composed of (1) painting sequence, (2) slicing order, and (3) orientations.
An example of individual decoding is in figure~\ref{fig:individual-decoding}.

Let us use the notation for painting sequence as $PS$, slicing order as $SO$, orientations $OR$.
$PS$ contains painting identifiers, $SO$ contains information used to construct slicing layout,
and $OR$ contains type of the cuts in the slicing layout – $H$ for horizontal, $V$ for vertical
and $*$ for wildcard, that can take up any value $H$ or $V$.

\subsubsection*{Random keys decoding}
Decoding both $PS_{rk}$ and $SO_{rk}$ is the same as the RKGA in~\cite{beanGeneticAlgorithmsRandom1994}.
The graphical illustration is in figure~\ref{fig:individual-decoding} marked as~\textit{random key decoder}.
Decoding random keys can be explained in the following steps on a sequence of four numbers $S = 0.3, 0.2, 0.4, 0.1$\,.

\begin{enumerate}
    \item Create $S'$ by adding a lower index to each element from $S$, which marks its ordinal position starting from one.
    $S' = 0.3_1, 0.2_2, 0.4_3, 0.1_4$\,.
    \item Sort $S'$ in descending order. $S' = 0.1_4, 0.2_2,  0.3_1, 0.4_3$\,.
    \item Take lower indexes of $S'$.
    It is the result – $4, 2, 1, 3$.
\end{enumerate}

\subsubsection*{Orientation probabilities decoding}

Last part of the individual, matrix $OR_{prob} \in \real^{N-1, 3}$, decodes to the sequence of symbols from $\Sigma_* = \{H, V, *\} $.
The graphical illustration is in figure~\ref{fig:individual-decoding} marked as~\textit{orientation decoder}.

Decoding $OR_{prob}$ translates each row to one symbol from $\Sigma_*$, producing a symbol sequence.
Thus, decoding orientation probabilities can be explained for one row, say $R = 0.7, 0.2, 0.1$
in the following steps.


\begin{enumerate}
    \item Create $R'$ by adding lower index $H$ to the first, $V$ to the second, and $*$ to the last $R$'s elements.
    $R' = 0.7_H, 0.2_V, 0.1_*$
    \item Select element from $R'$ with the maximum value. $\max R' = 0.7_H$.
    \item Take lower index of $\max R'$.
    It is the result – $H$.
\end{enumerate}

There is one exception to the steps described above.
It is the limit on the maximum number of $*$ symbols produced by orientation probabilities decoding.
Let us call this limit $k$.
If the limit is not applicable, i.e., $k \geq N-1$, there is no change to steps 1--3 described above.
However, if applicable, only the first $k$ symbols $*$ with the highest value are considered.
It is achieved by setting value to $0$ (only for the duration of the decoding) to the bottom $N-1-k$ symbols $*$ with the lowest values.
Then the same 1--3 steps are applied as described above.

One example where the limit applies is for the $k=1$ and $OR_{prob}$ that has two rows, $R_1 = 0.2, 0.3, 0.5$ and $R_2 = 0.1, 0.2, 0.7$.
Without exception, the result is $*, *$.
However, considering the exception on the maximum limit $k=1$, the result is $V, *$.
Reason is that in $R_2$, symbol $*$ has value $0.7$,
which is higher than value of $*$ in $R_1$, which is $0.5$.

\begin{figure}[h!]
    \includegraphics[width=1.1\textwidth, left]{individual_decoding}
    \caption{
        Individual decoding example. Both the painting sequence random key and slicing order random key
        are decoded using the same procedure. The decoded individual can be used to construct a slicing tree.
    }
    \label{fig:individual-decoding}
\end{figure}

\subsection{Slicing layout construction}\label{subsec:slicing-tree-construction}
In the previous subsection, decoding an individual is described.
The decoded individual consists of three parts – painting sequence, slicing order, and orientations.
With this representation, a slicing layout can be constructed.
This construction has three steps, which are as follows.

\begin{enumerate}
    \item Construct unresolved slicing tree from a decoded individual.
    \item Resolve an unresolved slicing tree.
    \item Create a slicing layout using a resolved slicing tree.
\end{enumerate}

\subsubsection*{Slicing tree construction}

First, let us describe what a slicing tree is.
The slicing tree was first introduced in 1982 by Otten~\cite{ottenAutomaticFloorplanDesign1982} to solve automatic floorplan design.
In the most general sense, it is a tree that recursively divides space into rectangles.
This thesis defines and uses the slicing tree in two variants.\\

\navesti{Resolved slicing tree} is a tree with internal nodes having values from $\Sigma = \{H, V\}$
and leafs having values from the painting sequence.\\

\navesti{Unresolved slicing tree} is an extension of a resolved slicing tree where internal nodes have values from $\Sigma_* = \{H, V, *\}$ \\

Symbols $H$ and $V$ are common for both types of the slicing tree.
$H$ means a horizontal cut and $V$ means a vertical cut.
An unresolved slicing tree can also contain the wildcard symbol $*$.
This symbol means a cut that best suits the use – wildcard can thus become both $H$ or $V$.
The presence of a wildcard symbol is a novel idea also proposed in this thesis. \todo{vice zduraznit}

Now, we can use a decoded individual to construct an unresolved slicing tree.
This construction is graphically illustrated in the left part of a figure~\ref{fig:slicing-tree-construction}.
During this process, the painting sequence results in leaf nodes, slicing order determines the shape of a tree, and orientations are the values assigned to internal nodes.
Thus, each decoded individual represents one unresolved slicing tree.

Finally, an unresolved slicing tree is resolved.
Resolving is graphically illustrated in the right part of a figure~\ref{fig:slicing-tree-construction},
where the unresolved tree contains one wildcard symbol $*$ as a root.
By resolving this tree, $*$ is first replaced by $H$ and then by $V$.
In this case, resolving the unresolved slicing tree produces two resolved slicing trees,
which differ in root node value.
In the general case, an unresolved slicing tree can at most resolve to $2^k$ resolved slicing trees,
where $k$ is the number of internal nodes, i.e., the nodes that can contain wildcard $*$.
Reformulation for a decoded individual is that decoded individual can, at most, represent
$2^k$ resolved slicing trees, where $k$ is the number of orientations.


\afterpage{%
    \clearpage% Flush earlier floats (otherwise order might not be correct)
    \begin{landscape}% Landscape page
        \begin{figure}[]
            \centering
            \includegraphics[width=1.5\textwidth]{slicing_tree_construction}
            \caption{
                On the left is an example of unresolved slicing tree construction from a decoded individual.
                On the right is an example of resolving an unresolved slicing tree.}
            \label{fig:slicing-tree-construction}
        \end{figure}
    \end{landscape}
    \clearpage% Flush page
}

\subsubsection*{Slicing layout}

Next, we can construct a slicing layout using a resolved slicing tree.\\

\navesti{Slicing layout} is the recursive partitioning of space to rectangles.\\

Creating a slicing layout from a slicing tree can be explained using an
example in figure~\ref{fig:slicing-layout-dimensions}.
We are given a space to partition. Let us call it layout. Also, we are given areas of rectangles to place.
Rectangles to place are the paintings, and the layout is the wall on which the paintings are being placed.
The example has rectangles $1,2,3$ with areas $a_1, a_2, a_3$.
This is depicted in the left part of the figure.
Then, we recursively traverse the resolved slicing tree.
Depending on the node value, there are three possible actions.

\begin{itemize}
    \item $H$ – cut layout horizontally.
    \item $V$ – cut layout vertically.
    \item Otherwise, assign node value to the layout.
\end{itemize}

After performing the cut, the process mentioned above is recursively repeated
for the left and right child.
If the cut is horizontal, the left child is given the upper part of the cut as its layout, and the right child is given the lower part.
If the cut is vertical, the left child is given the left part of the cut as its layout, and the right child is given the right part.
This can be seen in the middle part of the figure, where the cut is vertical.
The left child is an orphan, i.e., it has no children.
Thus, the left part of the cut is assigned value 1.
The right child is not an orphan, meaning the process is applied recursively to the right part of the cut and the right child.
It is depicted on the right part of the figure.

The last part of creating a slicing layout is the position of the cut points.
As mentioned above, there are two cut types – horizontal and vertical.
For each cut type, the position is determined proportionally to the area of rectangles assigned to the cut result.
Again, it can be described using an example in figure~\ref{fig:slicing-layout-dimensions}.
The first cut is vertical, where the left part of the cut is assigned rectangles $1$ and the right part is assigned rectangles $2,3$.
The vertical cut thus splits the layout into two parts – the left part having $1/3$ of the total layout area and the right part
having the rest.


\afterpage{%
    \clearpage% Flush earlier floats (otherwise order might not be correct)
    \begin{landscape}% Landscape page
        \begin{figure}
            \centering
            \includegraphics[width=1.5\textwidth]{slicing_layout_dimensions}
            \caption{Example of a slicing layout construction from a resolved slicing tree. There are three paintings, $1,2,3$ together with their areas $a_1, a_2, a_3$.
            The position of a cut is determined proportionally to the area of the paintings.} \label{fig:slicing-layout-dimensions}
        \end{figure}
    \end{landscape}
    \clearpage% Flush page
}


\newpage

\subsection{Placement heuristics}\label{subsec:placement-heuristics}
